## 3장 HTTP 메시지
 - 3장에서 다룰 주제
   - 메시지가 어떻게 흘러가는가
   - HTTP 메시지의 세 부분 ( 시작줄, 해더, 본문)
   - 요청과 응답 메시지의 차이
   - 요청 메시지가 지원하는 여러 기능(메서드)들
   - 응답 메시지가 반환하는 여러 상태 코드들
   - 여러 HTTP 헤더들은 무슨일을 하는가

### 3.1 메시지의 흐름
  - HTTP 메시지는 HTTP 에플리케이션 간에 주고받는 데이터의 블록들이다.

#### 3.1.1 메시지는 원 서버 방향을 인바운드로 하여 송신된다.
 - HTTP는 인바운드와 아웃바운드라는 용어를 트랜잭션 방향을 표현하기 위해 사용한다. ( 서버를 기준으로 생각한다. )
 - 인바운드 : 서버로 들어간다. ( ALL CLOSE )
 - 아웃바운드 : 서버에서 나간다. ( ALL OPEN )
  
#### 3.1.2. 다운 스트림으로 흐르는 메시지
  - 요청 메시지냐 응답 메시지냐에 관계없이 모든 메시지는 다운스트림으로 흐른다.  ( 먼소린지 ? )

### 3.2 메시지의 각 부분
  - HTTP 메시지는 클라이언트의 요청이거나 서버로부터의 응답 중 하나이다.
  - 메시지는 시작줄, 헤더, 본문 이렇게 세 부분으로 구성된다. ( 본문이 없을 수도 있다. )
  - 시작줄과 해더는 줄 단위로 분리된 아스키 문자열이다. ( 각 줄은 캐리지 리턴과 개행문자로 구성된 두 글자의 줄바꿈 문자열로 끝난다. 이를 'CRLF'라 부른다.) - 
  - CR : 커서의 위치를 맨 앞으로 이동
  - LF :  현재 위치에서 바로 아래로 이동
  - 본문은 텍스트나 이진 데이터를 포함할 수도 있고 비어있을 수도 있다.
  
  #### 3.2.1. 메시지 문법
   - 모든 HTTP 메시지는 요청 메시지나 응답 메시지로 분류된다.  ( 요청, 응답 모두 기본적인 구조는 같다. 
   - 해더나 엔터티 본문이 없더라도 HTTP 해더의 집합은 항상 빈 줄로 끝나야 한다. ( 테스트 해보기 )
   - 요청 메시지의 형식
     -  <메서드> <요청 URL> <버전>
     -  <헤더>
  
     -  <엔터디 본문>
  -  응답 메시지의 형식
     -  <버전> <상태 코드> <사유 구절>
     -  <헤더>
  
     -  <엔터티 본문>

#### 3.2.2 시작줄
 - 모든 HTTP 메시지는 시작줄로 시작한다.
 - 요청줄 : 요청 메시지는 서버에게 리소스에 대해 무언가 해달라고 부탁한다. 
 - 응답줄 : 응답 메시지는 수행 결과에 대한 상태 정보와 결과 데이터를 클라이언트에게 돌려준다.
 - 메서드 : 요청의 시작줄은 메서드로 시작하며, 서버에게 무엇을 해야 하는지 말해준다.
   - 메서드에 따라서 요청 메시지에 본문이 있는 경우도 있고 그렇지 않은 경우도 있다.

|메서드|설명|메시지 본문이 있는가 ?|
|------|---|---|
|GET|서버에서 어떤 문서를 가져온다.|없음|
|HEAD|서버에서 어떤 문서에 대해 해더만 가져온다.|없음|
|POST|서버가 처리해야 할 데이터를 보낸다.(서버에 데이터를 저장한다.)|있음|
|PUT|서버에 요청 메시지의 본문을 저장한다.|있음|
|FETCH|서버가 처리해야 할 데이터를 보낸다.|있음|
|TRACE|메시지가 프락시를 거쳐 서버에 도달하는 과정을 추적한다.|없음|
|OPTIONS|서버가 어떤 메서드를 수행할 수 있는지 확인한다.|없음|
|DELETE|서버에서 문서를 제거한다.|없음|

- POST VS PUT

- PUT VS FETCH


- 상태 코드 : 상태코드는 서버가 클라이언트에게 무엇이 일어났는지 말해준다. <-> 메서드
  - 상태코드는 응답의 시작줄에 위치한다.


|전체 범위|정의된 범위|분류|
|------|---|---|
|100-199|100-101|정보|
|200-299|200-206|성공|
|300-399|300-305|리다이랙션|
|400-499|400-415|클라이언트 에러|
|500-599|500-505|서버 에러|


- 사유 구절 : 상태 코드에 대한 글로 된 설명을 제공한다.
- 버전 번호 
  - 버전 번호는 HTTP/x.y 형식으로 요청과 응답 메시지 양쪽 모두에 기술된다.
  - 자신이 사용하는 프로토콜 버전을 상대방에게 말해주는 수단이다. 
  - 버전 번호는 분수로 다루어지지 않는다. -> 더 큰 버전을 비교하기 위해서는 .을 기준으로 좌우 숫자를 따로비교한다.  ( HTTP/2.22 > HTTP/2.3 )

#### 3.2.3 헤더
 - 시작줄 다음에는 0개 혹은 그 이상의 HTTP 헤더가 온다.
 - Key-Value 구조이다.
  
### 3.3 메서드
 - 모든 서버가 모든 메서드를 구현하지는 않는다. ( 서버 개발자 마음이다.. 단지 규격일뿐..)

#### 3.3.1 안전한 메서드 ( Safe Method )
 - GET, HEAD 메서드를 사용하는 HTTP 요청의 결과로 서버에 어떤 작용도 없기 때문에 안전한 메서드라고 한다. ( 이것 또한 3.3 처럼 서버 개발자가 구현하기 나름이다.. GET인데 POST처럼 구현해 놓을수도 있다...)
#### 3.3.2 GET
  - 주로 서버에게 리소스를 요청하기 위해 사용한다.
  - 데이터를 서버에 넘길때는 질의 문자열로 넘긴다. ( ex. http://www.naver.com/search?query=item..)
#### 3.3.3 HEAD
  - 기본동작은 GET과 같지만 서버는 응답으로 헤더만 돌려준다. ( 특정 리소스가 있는지 확인만 할 용도라면 유용할듯함 )
  - HEAD를 사용하면 ?
    - 리소스를 가져오지 않고도 그에 대해 무엇인가(타입 ? - 해당 리소스의 Content-type을 말하는 듯 )를 알아낼 수 있다.
    - 응답의 상태 코드를 통해, 개채가 존재하는지 확인할 수 있다.
    - 헤더를 확인하여 리소스가 변경되었는지 검사할 수 있다. ( ? 어떻게 ?)
#### 3.3.4 PUT
 - PUT메서드는 서버에 문서를 쓴다.
 - PUT 메서드의 의미는, 요청 URL에 해당하는 문서가 이미 서버에 있다면 본문에 있는 값으로 변경하고, 없다면 새 문서를 쓰는 것이다.
#### 3.3.5 POST
 - POST 메서드는 서버에 입력 데이터를 전송하기 위해 설계되었다. ( html form을 지원하기 위해 주로 사용된다. )
#### 3.3.6 TRACE
 - TRACE 메서드는 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다.
 - TRACE 메서드는 주로 진단을 위해 사용된다. 예를들어, 요청이 의도한 요청/응답 연쇄를 거쳐가는지 검사할 수 있다. 또한, 프락시나 다른 애플리케이션들이 요청에 어떤 영향을 미치는지 확인해보고자 할 때도 좋은 도구이다.
 - TRACE 요청은 어떠한 엔터티 본문도 보낼 수 없고, 응답 엔터티 본문에는 서버가 받은 요청이 그대로 들어있다.
#### 3.3.7 OPTIONS
 - OPTIONS 메서드는 서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼 수 있다.
#### 3.3.8 DELETE
 - 서버에게 요청한 URL로 지정한 리소스를 삭제할 것을 요청한다.

### 3.4 상태 코드
####
 - 3.4.1 100-199: 정보성 상태 코드
 - 
|상태 코드|사유 구절|의미|
|------|---|---|
|100|Continue||
|200-299|200-206|성공|


- 100 Continue는 HTTP 클라이언트 애플리케이션이 서버에 엔티티 본문을 전송하기 전에 그 엔터티 본문을 서버가 받아들일 것인지 확인하려고 할 때, 그 확인 작업을 최적화하기 위한 의도로 도입 된 것이다.

- 클라이언트와 100 Continue
- 서버와 100 Continue
- 프락시와 100 Continue
  
- 3.4.2 200-299: 성공 상태 코드
  - 

